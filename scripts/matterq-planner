#!/usr/bin/env python

import os
import sys
import argparse
import subprocess
import traceback
import cairo

MQ_SPOOLDIR = os.environ["MQ_SPOOLDIR"]
PLATE_PATH = os.path.join(MQ_SPOOLDIR, "plate", "depositions")


class Region(object):
    _colour = (0.0, 0.0, 0.0, 1.0)

    def __init__(self, limits):
        self._limits = limits

    @classmethod
    def from_str(cls, string):
        limits = {}

        for line in string.split("\n"):
            if len(line) == 0:
                continue

            parts = line.strip().split("\t")

            if parts[0] == "E":
                continue

            assert len(parts) == 3

            limits[parts[0]] = (float(parts[1]), float(parts[2]))

        assert set(limits.keys()) == set("XYZ")

        return cls(limits)

    @classmethod
    def from_file(cls, filename):
        return cls.from_str(open(filename).read())

    def get_z_safe(self):
        return self._limits["Z"][1]

    def shift(self, x, y):
        self._limits["X"] = (self._limits["X"][0] + x,
                             self._limits["X"][1] + x)
        self._limits["Y"] = (self._limits["Y"][0] + y,
                             self._limits["Y"][1] + y)

    def draw(self, ctx, outline=False):
        ctx.set_source_rgba(*self._colour)

        ctx.rectangle(self._limits["X"][0],
                      self._limits["Y"][0],
                      self._limits["X"][1] - self._limits["X"][0],
                      self._limits["Y"][1] - self._limits["Y"][0])

        if outline:
            ctx.stroke()
        else:
            ctx.fill()

    def __le__(self, other):
        return (self._limits["X"][0] >= other._limits["X"][0] and
                self._limits["X"][1] <= other._limits["X"][1] and
                self._limits["Y"][0] >= other._limits["Y"][0] and
                self._limits["Y"][1] <= other._limits["Y"][1])

    def __and__(self, other):
        for axis in ("X", "Y"):
            clear = ((other._limits[axis][0] < self._limits[axis][0] and
                      other._limits[axis][1] < self._limits[axis][0]) or
                     (other._limits[axis][0] > self._limits[axis][1] and
                      other._limits[axis][1] > self._limits[axis][1]))

            if clear:
                return False

        return True

    def __repr__(self):
        return "<%s(%f,%f,%f,%f)>" % (type(self).__name__,
                                      self._limits["X"][0],
                                      self._limits["Y"][0],
                                      self._limits["X"][1],
                                      self._limits["Y"][1])


class Deposition(Region):
    _colour = (1.0, 0.0, 0.0, 0.8)


class WorkArea(Region):
    def add_head_clearance(self, x1, x2, y1, y2):
        self._limits["X"] = (self._limits["X"][0] - x1,
                             self._limits["X"][1] + x2)
        self._limits["Y"] = (self._limits["Y"][0] - y1,
                             self._limits["Y"][1] + y2)


class NewArea(WorkArea):
    _colour = (0.0, 0.8, 0.0, 0.8)


class ShiftedArea(WorkArea):
    _colour = (0.0, 0.0, 0.8, 0.6)


class ResetArea(WorkArea):
    _colour = (1.0, 1.0, 0.0, 0.8)


def check_conflict(depositions, new):
    for d1 in depositions:
        for d2 in depositions:
            if d1 == d2:
                continue

            if d1 & d2:
                sys.stderr.write("Existing depositions conflict: %s & %s\n" %
                                 (d1, d2))
                assert False

        if d1 & new:
            return True


def parse_args():
    parser = argparse.ArgumentParser()

    parser.add_argument("filename",
                        type=str,
                        metavar="FILE",
                        help="Gcode file for which to plan printing")

    parser.add_argument("--svg",
                        default=None,
                        type=argparse.FileType("w"),
                        metavar="FILE",
                        help="Write planner SVG")

    parser.add_argument("--verbose",
                        action="store_true",
                        help="Explain what is being done")

    return parser.parse_args()


def main():
    args = parse_args()

    head = map(float, os.environ["MQ_HEADSIZE"].split(":"))
    assert len(head) == 4

    bedsize = map(float, os.environ["MQ_PRINTBED"].split(":"))
    assert len(bedsize) == 2

    bed = Region({"X" : (0.0, bedsize[0]), "Y" : (0.0, bedsize[1])})

    if args.svg is not None:
        surface = cairo.SVGSurface(args.svg, bedsize[0], bedsize[1])
        ctx = cairo.Context(surface)

        ctx.set_line_width(1.0)

        ctx.set_source_rgb(0.6, 0.6, 0.6)
        ctx.rectangle(0, 0, bedsize[0], bedsize[1])
        ctx.fill()

    # Load all existing depositions on the plate.

    depositions = []

    for filename in os.listdir(PLATE_PATH):
        d = Deposition.from_file(os.path.join(PLATE_PATH, filename))
        depositions.append(d)

        if args.svg is not None:
            d.draw(ctx)

    # Calculate safe working Z value.

    z = 0.0

    for d1 in depositions:
        zmin = max(z, d1.get_z_safe())

    # Create a Region with the intended working bounds of the new print so we
    # can check for conflicts with existing regions.

    p = subprocess.Popen(["austerus-verge", "-p", "-z", str(zmin + 5),
                          args.filename], stdout=subprocess.PIPE)

    assert p.wait() == 0
    out, err = p.communicate()

    new = NewArea.from_str(out)
    assert new <= bed

    new.add_head_clearance(*head)

    if args.svg is not None:
        new.draw(ctx, outline=True)

    # Create a Region where the Z axis will be homed (X0 Y0) so that we can
    # check it is safe to do so.

    zreset = ResetArea({"X" : (0.0, 0.0), "Y" : (0.0, 0.0)})
    zreset.add_head_clearance(*head)

    if args.svg is not None:
        zreset.draw(ctx)

    # Detect any conflicts

    shift = None

    if check_conflict(depositions, zreset):
        if args.verbose:
            sys.stderr.write("Z reset conflict error\n")

        if args.svg is not None:
            surface.finish()

        sys.exit(2)

    if check_conflict(depositions, new):
        if args.verbose:
            sys.stderr.write("Conflict with existing deposition\n")

        p = subprocess.Popen(["austerus-verge", "-pd", args.filename],
                             stdout=subprocess.PIPE)

        assert p.wait() == 0
        out, err = p.communicate()

        newdep = ShiftedArea.from_str(out)
        assert newdep <= bed

        newdep.add_head_clearance(*head)

        for y in range(-int(bedsize[1]), int(bedsize[1]), 5):
            if shift is not None:
                break

            for x in range(-int(bedsize[0]), int(bedsize[0]), 5):
                newdep.shift(x, y)

                if newdep <= bed:
                    if not check_conflict(depositions, newdep) and \
                       not check_conflict([zreset], newdep):
                        shift = x, y
                        break

                newdep.shift(-x, -y)

        if shift is None:
            if args.verbose:
                sys.stderr.write("Not enough room on build plate\n")

            sys.exit(2)

        if args.svg is not None:
            newdep.draw(ctx)

        if args.svg is not None:
            surface.finish()

        print "X\t%f" % shift[0]
        print "Y\t%f" % shift[1]

    else:
        if args.svg is not None:
            new.draw(ctx)

    print "Z\t%f" % zmin

    if args.svg is not None:
        surface.finish()

    if shift is None:
        sys.exit(0)
    else:
        sys.exit(1)


if __name__ == "__main__":
    try:
        main()
    except AssertionError:
        traceback.print_exc()
        sys.exit(3)


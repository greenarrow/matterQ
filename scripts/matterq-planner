#!/usr/bin/env python

import os
import sys
import argparse
import cairo

PLATE_PATH = "/tmp/plate"
WIDTH, HEIGHT  = 200, 200


class Region(object):
    _colour = (0.0, 0.0, 0.0, 1.0)

    def __init__(self, limits):
        self._limits = limits

    @classmethod
    def from_str(cls, string):
        limits = {}

        for line in string.split("\n"):
            if len(line) == 0:
                continue

            parts = line.strip().split("\t")

            if parts[0] == "E":
                continue

            assert len(parts) == 3

            limits[parts[0]] = (float(parts[1]), float(parts[2]))

        assert set(limits.keys()) == set("XYZ")

        return cls(limits)


    @classmethod
    def from_file(cls, filename):
        return cls.from_str(open(filename).read())

    def get_z_safe(self):
        return self._limits["Z"][1]

    def draw(self, ctx):
        ctx.set_source_rgba(*self._colour)

        ctx.rectangle(self._limits["X"][0],
                      self._limits["Y"][0],
                      self._limits["X"][1] - self._limits["X"][0],
                      self._limits["Y"][1] - self._limits["Y"][0])

        ctx.fill()

    def __and__(self, other):
        xover = ((other._limits["X"][0] >= self._limits["X"][0] and
                  other._limits["X"][0] <= self._limits["X"][1]) or
                 (other._limits["X"][1] >= self._limits["X"][0] and
                  other._limits["X"][1] <= self._limits["X"][1]))

        yover = ((other._limits["Y"][0] >= self._limits["Y"][0] and
                  other._limits["Y"][0] <= self._limits["Y"][1]) or
                 (other._limits["Y"][1] >= self._limits["Y"][0] and
                  other._limits["Y"][1] <= self._limits["Y"][1]))

        if xover and yover:
            return True

        return False

    def __repr__(self):
        return "<%s(%f,%f,%f,%f)>" % (type(self).__name__,
                                      self._limits["X"][0],
                                      self._limits["Y"][0],
                                      self._limits["X"][1],
                                      self._limits["Y"][1])


class Deposition(Region):
    _colour = (1.0, 0.0, 0.0, 0.8)


class NewArea(Region):
    _colour = (0.0, 0.8, 0.0, 0.8)


class ResetArea(Region):
    _colour = (1.0, 1.0, 0.0, 0.8)


def parse_args():
    parser = argparse.ArgumentParser()

    parser.add_argument("filename",
                        type=str,
                        metavar="FILE",
                        help="Gcode file for which to plan printing")

    parser.add_argument("--svg",
                        default=None,
                        type=argparse.FileType("w"),
                        metavar="FILE",
                        help="Write planner SVG")

    return parser.parse_args()


if __name__ == "__main__":
    args = parse_args()

    if args.svg is not None:
        surface = cairo.SVGSurface(args.svg, WIDTH, HEIGHT)
        ctx = cairo.Context(surface)

        ctx.set_line_width(1.0)

        ctx.set_source_rgb(0.6, 0.6, 0.6)
        ctx.rectangle(0, 0, WIDTH, HEIGHT)
        ctx.fill()

    # Load all existing depositions on the plate.

    depositions = []

    for filename in os.listdir(PLATE_PATH):
        d = Deposition.from_file(os.path.join(PLATE_PATH, filename))
        depositions.append(d)

        if args.svg is not None:
            d.draw(ctx)

    if args.svg is not None:
        surface.finish()

    # Detect any conflicts and calculate safe working Z value.

    z = 0.0

    for d1 in depositions:
        for d2 in depositions:
            if d1 == d2:
                continue

            if d1 & d2:
                sys.stderr.write("existing depositions conflict: %s & %s\n",
                                 (d1, d2))
                sys.exit(2)

        z = max(z, d1.get_z_safe())

    sys.stderr.write("safe moving Z: %f\n" % z)


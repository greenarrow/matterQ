#!/usr/bin/env python

import os
import sys
import argparse
import subprocess
import cairo

PLATE_PATH = "/tmp/plate"


class Region(object):
    _colour = (0.0, 0.0, 0.0, 1.0)

    def __init__(self, limits):
        self._limits = limits

    @classmethod
    def from_str(cls, string):
        limits = {}

        for line in string.split("\n"):
            if len(line) == 0:
                continue

            parts = line.strip().split("\t")

            if parts[0] == "E":
                continue

            assert len(parts) == 3

            limits[parts[0]] = (float(parts[1]), float(parts[2]))

        assert set(limits.keys()) == set("XYZ")

        return cls(limits)

    @classmethod
    def from_file(cls, filename):
        return cls.from_str(open(filename).read())

    def get_z_safe(self):
        return self._limits["Z"][1]

    def draw(self, ctx):
        ctx.set_source_rgba(*self._colour)

        ctx.rectangle(self._limits["X"][0],
                      self._limits["Y"][0],
                      self._limits["X"][1] - self._limits["X"][0],
                      self._limits["Y"][1] - self._limits["Y"][0])

        ctx.fill()

    def __le__(self, other):
        return (self._limits["X"][0] >= other._limits["X"][0] and
                self._limits["X"][1] <= other._limits["X"][1] and
                self._limits["Y"][0] >= other._limits["Y"][0] and
                self._limits["Y"][1] <= other._limits["Y"][1])

    def __and__(self, other):
        for axis in ("X", "Y"):
            clear = ((other._limits[axis][0] < self._limits[axis][0] and
                      other._limits[axis][1] < self._limits[axis][0]) or
                     (other._limits[axis][0] > self._limits[axis][1] and
                      other._limits[axis][1] < self._limits[axis][1]))

            if not clear:
                return True

        return False

    def __repr__(self):
        return "<%s(%f,%f,%f,%f)>" % (type(self).__name__,
                                      self._limits["X"][0],
                                      self._limits["Y"][0],
                                      self._limits["X"][1],
                                      self._limits["Y"][1])


class Deposition(Region):
    _colour = (1.0, 0.0, 0.0, 0.8)


class WorkArea(Region):
    def add_head_clearance(self, x1, x2, y1, y2):
        self._limits["X"] = (self._limits["X"][0] - x1,
                             self._limits["X"][1] + x2)
        self._limits["Y"] = (self._limits["Y"][0] - y1,
                             self._limits["Y"][1] + y2)


class NewArea(WorkArea):
    _colour = (0.0, 0.8, 0.0, 0.8)


class ResetArea(WorkArea):
    _colour = (1.0, 1.0, 0.0, 0.8)


def check_conflict(depositions, new):
    for d1 in depositions:
        for d2 in depositions:
            if d1 == d2:
                continue

            if d1 & d2:
                sys.stderr.write("existing depositions conflict: %s & %s\n" %
                                 (d1, d2))
                sys.exit(2)

        if d1 & new:
            return True


def parse_args():
    parser = argparse.ArgumentParser()

    parser.add_argument("filename",
                        type=str,
                        metavar="FILE",
                        help="Gcode file for which to plan printing")

    parser.add_argument("--svg",
                        default=None,
                        type=argparse.FileType("w"),
                        metavar="FILE",
                        help="Write planner SVG")

    return parser.parse_args()


if __name__ == "__main__":
    args = parse_args()

    head = map(float, os.environ["MQ_HEADSIZE"].split(":"))
    assert len(head) == 4

    bedsize = map(float, os.environ["MQ_PRINTBED"].split(":"))
    assert len(bedsize) == 2

    bed = Region({"X" : (0.0, bedsize[0]), "Y" : (0.0, bedsize[1])})

    if args.svg is not None:
        surface = cairo.SVGSurface(args.svg, bedsize[0], bedsize[1])
        ctx = cairo.Context(surface)

        ctx.set_line_width(1.0)

        ctx.set_source_rgb(0.6, 0.6, 0.6)
        ctx.rectangle(0, 0, bedsize[0], bedsize[1])
        ctx.fill()

    # Load all existing depositions on the plate.

    depositions = []

    for filename in os.listdir(PLATE_PATH):
        d = Deposition.from_file(os.path.join(PLATE_PATH, filename))
        depositions.append(d)

        if args.svg is not None:
            d.draw(ctx)

    # Create a Region with the intended working bounds of the new print so we
    # can check for conflicts with existing regions.

    p = subprocess.Popen(["austerus-verge", "-p", args.filename],
                         stdout=subprocess.PIPE)

    assert p.wait() == 0
    out, err = p.communicate()

    new = NewArea.from_str(out)
    assert new <= bed

    new.add_head_clearance(*head)

    if args.svg is not None:
        new.draw(ctx)

    # Create a Region where the Z axis will be homed (X0 Y0) so that we can
    # check it is safe to do so.

    zreset = ResetArea({"X" : (0.0, 0.0), "Y" : (0.0, 0.0)})
    zreset.add_head_clearance(*head)

    if args.svg is not None:
        zreset.draw(ctx)


    # Detect any conflicts

    if check_conflict(depositions, new):
        sys.stderr.write("conflict with existing deposition\n")

        p = subprocess.Popen(["austerus-verge", "-pd", args.filename],
                             stdout=subprocess.PIPE)

        assert p.wait() == 0
        out, err = p.communicate()

        newdep = NewArea.from_str(out)
        assert newdep <= bed

        newdep.add_head_clearance(*head)

        if args.svg is not None:
            newdep.draw(ctx)

        if args.svg is not None:
            surface.finish()

        if args.svg is not None:
            surface.finish()

        sys.exit(1)

    if check_conflict(depositions, zreset):
        sys.stderr.write("Z reset conflict error: %s\n")

        if args.svg is not None:
            surface.finish()

        sys.exit(2)

    # Calculate safe working Z value.

    z = 0.0

    for d1 in depositions:
        z = max(z, d1.get_z_safe())

    sys.stderr.write("safe moving Z: %f\n" % z)

    if args.svg is not None:
        surface.finish()

